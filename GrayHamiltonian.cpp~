/* GrayHamiltonianSearch.cpp

   Cilk program for finding a Hamiltonian cycle in a modular Gray graph.
   Created by jfan for CS49 Parallel Algorithms.

   usage: GrayHamiltonian [radices] -n [sequence length] -v [verbosity] 
     [radices]: a string of mixed or fixed integer radices encased in 
                quotation marks and delimited by spaces.
                e.g. GrayHamiltonian "2 3 4"

		In the case above, the mixed-radix tuple will be
		(2,3,4), listed from most significant to least
		significant radix. (However, the radices will be
		stored as an integer array from lsb to msb.)
  
     -n [sequence length]: (optional) an integer sequence length,
                required if we decide to perform a Gray Hamiltonian
                search only on that particular value of n. Otherwise,
                the program will perform the search on all possible
                values of n starting from n=2 and going to n=(product
                of the radices).  
		e.g. GrayHamiltonian "2 3 4" -n 13

		If n is NOT provided above, the program will search
		for a Hamiltonian cycle using the radices (2,3,4) and
		the sequence lengths n=3 to n=23.

		The program will alert the user if the input sequence
		length is invalid (most commonly, if n surpases the
		highest possible number representable with the
		specified radices)

     -v [verbosity]: (optional) changes the verbosity from default 2,
                which for each value of n prints a progress bar and,
                if no Hamiltonian cycle is found, an appropriate alert
                with the search status.
		e.g. GrayHamiltonian "2 3 4" -v 3

		-v 1 outputs only the values of n for which there is
                     no Hamiltonian cycle
		-v 2 outputs the above, plus progress bars and time 
		     lapse for each value of n tried
		-v 3 outputs the above, plus the Hamiltonian cycle if 
		     one is found
		-v 4 (not recommended) outputs the above, plus the 
		     stack trace as the recursive backtracking search 
		     is running

     --help: prints the help page from the local README file

   main function takes as an arg a set of mixed radices (input msb to
   lsb; stored lsb to msb) and optionally, the sequence length n,
   generates the Gray graph as an 2D adjacency array, and performs a
   modified DFS for a Hamiltonian cycle. It also performs
   preprocessing for those cases of radices and sequence lengths where
   it is known that a Hamiltonian cycle is impossible.
*/

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef NOCILK
#define cilk_spawn
#define cilk_sync
#define cilk_for for
#else
#include <cilk/cilk.h>
#include <cilk/cilk_api.h>
#endif

#include "GrayHamiltonian.h"
#include "util.h"
#include "timer.h"

/* ===================== STRUCTS AND MACROS ======================= */

/* Verbosity argument can be reset in the command line using -v */
int verbosity = 2;

/* ========================= FUNCTIONS ============================ */

/* Creates the valueToRep map for easy conversion one way */
void populateConversionTable(int** valueToRep, int nHigh,
			     int k, int* radices) {			     
  /* Store the values and reps in the conversion tables in integer
     order */

  int* rep = (int *) calloc(nHigh, sizeof(int));
  valueToRep[0] = rep;
  //std::map<int*, int> repToValueLocal;
  //repToValueLocal[rep] = 0;
  //conversionTable->repToValue[rep] = 0;

  for (int v = 1; v < nHigh; v++) {
    rep = increment(rep, k, radices);
    valueToRep[v] = rep;
    //repToValueLocal[rep] = v;
    //printf("v = %d; rep = ", v); printv(k, rep); printf("\n");
  }
  //conversionTable->repToValue = repToValueLocal;
  /*  
  for (int v = 0; v < nHigh; v++) {
    printf("v = %d = ", v); printv(k, conversionTable->valueToRep[v]);
    printf(" = %d\n", conversionTable->repToValue[conversionTable->valueToRep[v]]);
  }
  */
}

/* Creates the Gray adjacency graph, a 2D integer array where graph[v]
   lists the integers that share the Gray-code property with v.
*/
void populateGraph(graph_t graph, int** valueToRep,
		   int n_, int k, int* radices) {
  /*
  for (int v = 0; v < n_; v++) {
    printf("v = %d = ", v); printv(k, valueToRep[v]); printf("\n");
    //printf(" = %d\n", conversionTable->repToValue[conversionTable->valueToRep[v]]);
  }
  */

  // build the adjacency list for each vertex v. The list is at most
  // size 2k
  for (int v = 0; v < n_; v++) {
    graph[v] = (int*) calloc(2*k, sizeof(int));
    int* V = valueToRep[v];
    
    int index = 0;
    //printf("v = %d = ", v); printv(k, V); printf(": ");

    // at most two neighbors for each digit
    for (int i = 0; i < k; i++) {

      // upper neighbor u
      int* U = copy(V, k);
      U[i] = (U[i]+1) % radices[i];
      int u = decimal(U, k, radices);
      if (u < n_) {
	graph[v][index++] = u;
	/*
	if (!(checkGray(U, V, k, radices)))
	  printf("ERROR");
	printf("u = %d = ", u); printv(k, U); printf(", ");
	*/
      }
      free(U);
      
      // lower neighbor w
      if (radices[i] != 2) {
	int* W = copy(V, k);
	W[i] = (radices[i]+W[i]-1) % radices[i];
	int w = decimal(W, k, radices);
	if (w < n_) {
	  graph[v][index++] = w;
	  /*
	  if (!(checkGray(W, V, k, radices)))
	    printf("ERROR");
	  printf("w = %d = ", w); printv(k, W); printf(", ");
	  */
	}
	free(W);
      }
    }
    printf("\n");
  }
}

/* Increments the digit representation given the radices */
int* increment(int* rep, int k, int* radices) {
  int* repCopy = copy(rep, k);
  for (int i = 0; i < k; i++) {
    if (repCopy[i] + 1 == radices[i])
      repCopy[i] = 0;
    else {
      repCopy[i]++;
      break;
    }
  }
  return repCopy;
}

/* Checks whether two digit representations hold the modular Gray code
   property with the given radices */
int checkGray(int* rep1, int* rep2, int k, int* radices) {
  int differ = 0;
  // check every digit
  for (int i = 0; i < k; i++) {

    // if the digits differ, check that the Gray-code property holds
    if (rep1[i] != rep2[i]) {
      if (++differ > 1)
	return 0;
      
      bool Gray = (abs(rep1[i]-rep2[i]) ||
		   (rep1[i] == 0 && rep2[i] == radices[i]-1) ||
		   (rep2[i] == 0 && rep1[i] == radices[i]-1));	
      if (!(Gray))
	return 0;
    }
  }
  return 1;
}

/* Main algorithm: perform recursive backtracking Hamiltonian search
   on the given graph. Meanwhile, check off vertices in visited and
   build the cycle in solution */
search_t* HamiltonianSearch(graph_t graph, int** valueToRep,
			    int* visited, int* solution, int endIndex,
			    int n_, int k, int* radices) {
  search_t* searchResults = (search_t *) calloc(1, sizeof(search_t));

  /* are there any more vertices to visit?
  int recurse = 1;
  for (int i = 0; i < n_; i++) {
    recurse |= visited[i];
    if (recurse == 0)
      break;
  }
  */

  if (endIndex == n_-1) {
    // base case: no vertices left to visit; try to return to 0
    if (checkGray(valueToRep[0], valueToRep[solution[endIndex]],
		  k, radices)) {
      searchResults->found = 1;
      searchResults->cycle = solution;
    }
    // else, searchResults->found = 0 (default)
  } else {

    /* Recursively build the solution Hamiltonian cycle */

    int v = solution[endIndex];
      
    // iterate through all the neighbors u of v
    for (int i = 0; i < 2*k; i++) {
      int u = decimal(graph[solution[endIndex]], k, radices);

      if (visited[u])
	continue;
      else {
	int* visitedCopy(visited);
	int* solutionCopy(solution);

	// visit vertex u and add it to solution
	visitedCopy[u] = 1;
	solutionCopy[++endIndex] = u;

	searchResults = HamiltonianSearch(graph, valueToRep,
					  visitedCopy, solutionCopy,
					  endIndex,
					  n_, k, radices);

	// return right away if a solution has been found
	if (searchResults->found)
	  return searchResults;
      }
    }
  }
  return searchResults;
}

/* Driver to perform Hamiltonian search on a Gray graph */
int main(int argc, char **argv) {

  if (argc < 2 || askHelp(argc, argv)) {
    displayReadme();
    exit(1);
  }

  args_t* args = parseArguments(argc, argv);
  if (args->error) {
    printf("ERROR: %s", args->errMsg);
    freeArgs(args);
    exit(1);
  }

  // make local copies of option arguments
  int n = args->n;
  int k = args->k;
  printf("r = "); printv(k, args->radices);
  int* radices = reverse(args->radices, k);
  verbosity = args->v;
  
  // find the range of n values to iterate through
  int nLow, nHigh;
  if (n != 0) {
    nLow = n;
    nHigh = n;
    printf("; n = %d\n", n);
  } else {
    nLow = 2;
    nHigh = radixProduct(k, radices);
    printf("; n = 2 to n = %d\n", nHigh);
  }

  // create map that allows easy conversion to digit representation
  int** valueToRep = (int**) calloc(nHigh, sizeof(int*));
  populateConversionTable(valueToRep, nHigh, k, radices);

  // compute Hamiltonian cycles for n_ = nLow to n_ = nHigh
  for (int n_ = nLow; n_ <= nHigh; n_++) {
    graph_t graph = (graph_t) calloc(n_, sizeof(int *));

    printf("n_ = %d", n_); fflush(stdout);
    populateGraph(graph, valueToRep, n_, k, radices);

    int visited[n_]; int solution[n_];
    visited[0] = 1;
    search_t* searchResults =  HamiltonianSearch(graph, valueToRep,
						 visited, solution, 0,
						 n_, k, radices);

    if (!(searchResults->found))
      printf("not found");
    printf("\n");
    
    freeGraph(graph, n_);
  }
  
  freeArgs(args);
  freeConversionTable(valueToRep, nHigh);
  return 0;
}
